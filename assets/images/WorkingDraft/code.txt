
SYSTEM COMMANDLINE USAGE				[20181015]

While the batch files under QuickLaunch help simplify Eamon CS usage, the system adheres to the long tradition of C-based programs, making extensive use of commandline flags.  Flags are a mechanism to pass information into a program run from a commandline; there are a wide variety of flags available and they will be detailed here.  The implication of this is that Eamon CS can be run in customized configurations via either DOS prompt/Unix shell or new user-created batch files.  As a side note:  the QuickLaunch batch files use flags extensively and should be the first place you look to see examples of what combinations of flags can be used together to run a particular program.



CREATING CUSTOM ADVENTURE CLASSES			[20180930]

Custom games are built in Eamon CS using the common C# mechanism of subclassing.  The system has no sealed classes and every property and method has been declared as virtual, allowing you to override any aspect of the game engine to suit your needs.  If you want to produce a complex, interesting game with a lot of special effects you will almost certainly need to create new classes for your adventure.  There are numerous examples of this in the adventures located in the Eamon.Adventures solution.  It turns out, the layout of folders and namespaces in Eamon CS lends itself to a simple code generation mechanism based on a template that was discovered while studying the already-created games.  You can use the Adventure Support Menu to generate one or more custom classes, complete with corresponding interfaces (if needed), based on many classes in the Eamon, EamonDD or EamonRT libraries.  These generated classes are added to the selected adventure and then you are free to add your custom code.  If the added class has a corresponding .XML file (eg, Room.cs and ROOMS.XML) it will be updated to reflect the newly added class.

While the code generator works great with classes that fit the template, it may fail with others that don't, so this comes with a caveat and a warning:  ALWAYS VERIFY THE GENERATED CODE IS WHAT YOU ARE EXPECTING.  DEPENDING ON THE CLASS, SOMETIMES THE CODE WILL BE FLAWED AND YOUR GAME WON'T COMPILE; OTHER TIMES IT WILL COMPILE BUT WILL BE SUBTLY WRONG.  Since this is intended simply as a bootstrapper you are responsible for ensuring what is produced will suit your needs (using intellisense helps in this regard).


DELETING CUSTOM ADVENTURE CLASSES			[20181007]

You can delete custom adventure classes just as easily as you add them using the Adventure Support Menu.  There are a number of reasons you may wish to do this.  When you create a new adventure via the Add A Custom Adventure menu option, a complete set of custom classes is generated for it, but you will often find that you don't need all the classes produced.  A generated class is only useful if you plan on overriding methods or properties in it; otherwise, it is just extraneous code bloat.  There may be other times you are implementing some special game behavior, when you run into trouble and decide to restart the work, or scrap it entirely.  Regardless of the reason, you can use the Delete Custom Adventure Classes menu option to delete one or more classes or interfaces from the game.  If you have classes that are reliant on explicitly deleted interfaces your game will not compile until the classes are fixed or removed.  If you delete classes, any paired interfaces will automatically be deleted as well.  If the deleted class has a corresponding .XML file (eg, Room.cs and ROOMS.XML) it will be updated to reflect the appropriate parent class.  Obviously, this operation cannot be undone so back up your work if there is a chance you'll change your mind.




BUILDING NEW ADVENTURES					[20180731]

As with any Eamon, it is still possible to send adventurers to their death for fun and profit, even after all these years!  You have the ability to create new games with the tools available to you.  If you want to create Standard adventures - that is, those that use the EamonRT generic game engine and have no custom programming - you can build them without Visual Studio 2017 Community Edition installed.  But to build Custom adventures (like The Beginner's Cave, etc) the VS tool suite should be on your system.  Up to this point it has been a manual effort to bootstrap new games, but great progress has been made towards fully automating the process.  You will find in the EamonDD folder under QuickLaunch a new .bat or .sh file that when run will enable an Adventure Support Menu under Utilities.  This is the LoadAdventureSupportMenu .bat or .sh file.  Before launching this menu for the first time, there may be a few manual steps that you must do if you plan to create Custom adventures.

There is a new project in Eamon.Desktop called EamonVS that integrates with the Microsoft EnvDTE automation library.  EnvDTE is not included in Eamon CS (it is not on Microsoft's redistribution list), but was dropped on your system when you installed Visual Studio.  EamonVS includes it as a reference.  The EamonDD program uses EamonVS to automate the process of adding new Custom adventure projects to Eamon.Desktop and to recompile the solution.  Note the following:

Scenario #1:  If you are using Visual Studio 2017 Community and it was installed in the default location you should be ready to go right now.  Simply open Eamon.Desktop, right click on the EamonVS project and Build it.  (If the Build fails with the system complaining it can't find EnvDTE.dll you're in Scenario #2 - see below).

Scenario #2:  If you are using Visual Studio 2017 and it was installed in a non-default location, or you're using a non-Community Edition (eg, Professional or Enterprise) you will have to remove the EnvDTE reference from EamonVS, locate EnvDTE in your Visual Studio directory heirarchy and re-add it as a reference to EamonVS.  The EnvDTE library should be about 256KB in size.  Once you do this you should be able to compile EamonVS.


There is one additional step you must do for Scenario #2.  The devenv.exe program should be in the same directory as EnvDTE.dll; you must edit the LoadAdventureSupportMenu.bat file (but not .sh) and add to the end of the launch line:

	-dep "[FullPathToDevEnvExe]\devenv.exe"

Before proceeding further, if you downloaded the .zip file for Eamon CS it might make sense to backup your repository so you can revert if necessary.  For those who cloned the repository from GitHub, it might make sense to create a branch for your new adventure so you can back out at any time.

Anyone who wishes to build a game with the intent to submit it for inclusion in Eamon CS should contact me to discuss the matter before beginning any work.  At the risk of putting on my (hopefully benevolent) dictator's hat, there are things that will be accepted into master and there are things that won't.  Unlike the original Eamon which took a very free-wheeling approach to game submissions, you can only be guaranteed that your code will go into master if we discuss the idea and it is approved.  Apologies if that sounds heavy-handed, or goes against the spirit of the original.  Ultimately my goal is to continue to improve the experience for people who discover Eamon CS and play it in the future.  Off hand, I think the only stuff from Classic Eamon that wouldn't make it past the gate is the truly infamous content or adventures with no plot and enemies like rat1, rat2, rat3 etc.  So we're not talking about overly stringent criteria here.  There are eight adventures in the collection, more to come, that demonstrate the kind of games I'd love to incorporate.

Once you have performed any manual steps listed above, you will be able to run LoadAdventureSupportMenu and create either Standard or Custom adventures (.bat only) by just entering a few key pieces of data.  The entire process has been automated by bootstrapping using the AdventureTemplates folder, located under Adventures:

	1. Creates the game folder under Adventures
	2. Generates all needed code (Custom adventures only)
	3. Creates all necessary QuickLaunch .bat and .sh files
	4. Adds game to appropriate Adventure database(s)
	5. Adds game project to Eamon.Desktop.sln (*) (Custom adventures only)
	6. Rebuilds Eamon.Desktop.sln, producing game library (Custom adventures only)

(*) The game project is added to the root of the Eamon.Desktop solution.  You should load Eamon.Desktop into Visual Studio 2017 and manually move the game project by left-clicking on the project and dragging it onto the Adventures folder.  Then click the Save-All button (in the red circle).

The only thing you need to do to play your game after all this is run the game's Edit[YourAdventureName] .bat or .sh file and add:
	
	1. A Module record
	2. A Room record

For Custom adventures, a complete set of derived foundational classes (eg, Artifact, Monster, Room, Engine, etc) are generated and available for you to program against.  The generated classes should be sufficient for many Custom games but remember you can always add your own new or overridden classes if you need to get exotic.  The entire system was built to be overridden so the sky is the limit here.



DELETING EXISTING ADVENTURES				[20180808]

You can also delete adventures from Eamon CS if the need arises.  Maybe you were experimenting with a game scenario that didn't work out, or have fully played through a title and want to make space on your file system.  Perhaps you simply don't like an adventure and want to purge it from your Eamon CS repository.  Whatever the reasons, the Adventure Support Menu has an option to do a game deletion.  Choosing this menu option will cause the system to prompt you for some key pieces of data, and verify that you want to proceed.  If so, it will completely remove all traces of the adventure from your Eamon CS system by doing the following:

	1. Delete game library/binary files (Custom adventures only)
	2. Remove game project from Eamon.Desktop.sln (*) (Custom adventures only)
	3. Remove game from appropriate Adventure database(s)
	4. Deletes the game folder under Adventures
	5. Deletes the game QuickLaunch .bat and .sh files

(*) The game project will be found if it is in the Adventures folder or the solution root; it will be deleted in either case.

If you delete a custom adventure in Unix, you will have to manually remove the game project from Eamon.Desktop.sln since Visual Studio integration is not available on that platform.  

As you might expect, once a game has been deleted its data is not recoverable by normal means.

[insert image]





There is one more menu option awaiting implementation.  It is intended to be run on a game after it has been fully implemented; this option should strip out the generated classes that were unused and replace them with their non-customized equivalents (eg, Eamon.Game.Artifact, etc).  The relevant game .XML files would also be updated.  This is strictly an optimization measure to reduce code bloat.






Bootstrapping new games has gone from painful to trivial, literally enter a few key bits of info and
the system auto-generates EVERYTHING, right down to compiling the custom .DLL for you, right from 
the EamonDD menu!



Things to note:

	1.  The EamonVS project has a reference to EnvDTE.dll.  This is configured as though you've installed Visual Studio 2017 Community edition on your
		system and are using it for ECS development.  If this is the case, the EamonVS project will compile RIGHT NOW.
	2.  If you installed VS 2017 CE in a non-default location or are using a different version of VS 2017 (eg, Profession or Enterprise), then you
		will need to do the following to get EamonVS to compile:

		a.  Delete the EnvDTE.dll reference
		b.  Right click on References, locate the EnvDTE.dll specific to your development environment (it should be approx. 256KB in size) and
			add it to EamonVS's References list.
	



A LoadAdventureDesignMenu.bat that works for Visual Studio 2017 Enterprise:

@echo off
cd ..\..\..\System\Bin
dotnet .\EamonPM.WindowsUnix.dll -pfn EamonRT.dll -rge -dep "C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\Common7\IDE\devenv.exe"



------------------------------------------------------------------------------

When you inquire with the burly Irishman about the adventures available to you
he says, "Ye cannat wait to put yerself to the test, eh?  Well, maybe one of
these will suit yer fancy."

------------------------------------------------------------------------------

  1. Test Adventure
  2. Demo Adventure
  3. The Beginner's Cave
  4. Beginner's Forest
  5. The Training Ground
  6. The Sub-Aquan Laboratory
  7. A Runcible Cargo
  8. Stronghold of Kahr-Dur
  9. The Temple Of Ngurct
 10. Wrenhold's Secret Vigil
 11. Tomb Of Horrors
 12. Dwellers of the Forbidden City
 13. The Isle Of Dread
 14. Gulliver's Travels
 15. The Temple Of Apshai

------------------------------------------------------------------------------

Press any key to continue or X to exit:

------------------------------------------------------------------------------

------------------------------------------------------------------------------

Enter the selection or X to exit:





Add this game to adventure database "SCIFI.XML" (Y/N) [N]: N

------------------------------------------------------------------------------

Add this game to adventure database "CONTEMPORARY.XML" (Y/N) [N]: N

------------------------------------------------------------------------------

Add this game to adventure database "TEST.XML" (Y/N) [N]: N

------------------------------------------------------------------------------

Add this game to adventure database "WIP.XML" (Y/N) [N]: N

------------------------------------------------------------------------------

If you would like to add this adventure to one or more custom adventure
databases, enter those file names now (eg, HORROR.XML).  To skip this step, or
if you are done, just press enter.

Enter name of custom adventure database:

------------------------------------------------------------------------------

Creating DTE... done
Opening solution... done
Adding new project... done
Saving solution... System.Runtime.InteropServices.COMException (0x8001010A): The
 message filter indicated that the application is busy. (Exception from HRESULT:
 0x8001010A (RPC_E_SERVERCALL_RETRYLATER))
   at EnvDTE.SolutionClass.SaveAs(String FileName)
   at EamonVS.VisualStudioAutomation.AddProjectToSolution(String projName)
Rebuilding solution... done

------------------------------------------------------------------------------

The adventure was successfully created.

------------------------------------------------------------------------------
|                            ADVENTURE DESIGN MENU                           |
------------------------------------------------------------------------------

1. Add a standard adventure.
2. Add a custom adventure.
3. Delete an adventure.
4. Delete custom adventure unused classes.
X. Exit.

[X]:







Add a standard adventure
Add a custom adventure
Delete an adventure
Delete custom adventure unused classes


Connecting to Visual Studio... done
Opening Eamon.Desktop.sln solution file... done
Adding ExpeditionToTheBarrierPeaks.csproj to solution... done
Saving solution file... done
Building solution file... done
Disconnecting from Visual Studio... done




SUGGESTED GAMEPLAY SETTINGS				[20180718]

Eamon CS runs as a set of 64-bit Console applications.  It became obvious over the course of development that the default settings for Console windows are not ideal when playing a text-based game.  The system tries to adjust the window size to an optimal setting, but you may wish to experiment with the other settings to see what appeals to you.  Rather than being simply a triviality, I've found that these aesthetics make a big difference in the quality of the gameplay as well as the ease of use for tools like EamonDD.  Obviously this entire topic is highly subjective, but the following ideas produced some interesting results:

1.  When running ECS, right click on the Console window title bar and choose properties.  Be aware the following settings are taken from Windows 10; the exact properties available on other versions may differ.

[Image here]

2.  Font Tab -
	Size:  12-16
	Font:  Consolas or Deja Vu Sans Mono
	Bold:  Optional

3.  Layout Tab -
	Screen Buffer Size -
		Width:  80
		Height:  9999
	Window Size -
		Width:  80
		Height:  50 (you can adjust this up or down based on screen resolution)

4.  Colors Tab -
	Screen Text -
		Selected Color Values -
			Red:  0
			Green:  255
			Blue:  0
	Screen Background -
		Selected Color Values -
			Red:  0
			Green:  0
			Blue:  0

Eamon CS tries to set the values on the Layout Tab to those shown above, so you shouldn't need to change them.  The Screen Buffer Width and Window Width should always be 80 columns.  The Screen Buffer Height is strongly suggested to be 9999.  The Screen Text shown above is Green with a Black background.  This has a nice, retro-vibe to it, like an Apple II green screen.  If you prefer amber the RGB values [255,165,0] might work for you.  As time has passed, I settled on a white background with black text, as shown in the various images in this document.  Once you have settings you're happy with, click OK and they should persist across ECS programs.

MISCELLANEOUS GAMEPLAY NOTES				[20180718]

The parser of the game has been enhanced to allow more flexible input.  You can say stuff like "PUT my sword INSIDE my backpack" or "OPEN that jewelry box" or "ATTACK the rats" or "GIVE the spices TO the hermit".  The standard [VERB] [subject1] [subject2] pattern of Eamon Deluxe remains, but ECS will discard the articles before processing further.  Even though it is more typing, some players may find it more immersive.  Of course, you can always just use the more terse syntax if you prefer.

There are a few new commands that have been added to the game engine:

1.  "INFO" gives information about the adventure being played.

2.  "VERBOSE" [rooms|artifacts|monsters|all] turns verbosity on or off on the appropriate record type (in practice you’ll probably only ever want rooms).

3.  "HINTS" gives you a list of hints for the current adventure.  You should always carefully read EAMON CS 1.4 GENERAL HELP and EAMON CS 1.4 NEW COMMANDS as these hints may be subtly different than their Eamon Deluxe counterparts.  In particular consider the following:

4.  "GO" [door] allows you to pass through a free standing non-directional door (eg: the overgrown path in Test Adventure).

5.  "INVENTORY" [container] has been added as a parallel to "INVENTORY" [monster].  This lists the container's contents.









PREREQUISITES				[20180715]

As mentioned in the README.md, Eamon CS has no formal installer.  There are good points and bad points to this.  On one hand, it is a simple matter of unzipping the Eamon-CS-master.zip file downloaded from GitHub to set up for play (if you did that, as opposed to doing a Git Clone).  Also, it means there is no installer to maintain, which frees time up for other things like engine enhancements, or developing content.

A disadvantage to this approach is the ECS developer/gamer is responsible for ensuring that all prerequisites are installed on their system; otherwise, ECS will not run when you double-click on any of the .bat or .sh QuickLaunch files.  This is typically manifested by a console window popping up and then disappearing quickly... caused by a missing dotnet.exe program.  If you find that you cannot get Eamon CS to run, your first order of business should be to download and install the following files (in order):

Developers who want to play, step through and/or develop the source code:

https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=Community&rel=15		(Only if you need VS 2017)
https://www.microsoft.com/net/download/thank-you/net472-developer-pack
https://www.microsoft.com/net/download/thank-you/dotnet-sdk-2.1.302-windows-x64-installer

Gamers who simply want to play:

https://www.microsoft.com/net/download/thank-you/net472-offline
https://www.microsoft.com/net/download/thank-you/dotnet-runtime-2.1.2-windows-x64-installer

A second disadvantage on Windows leads to a useful tip regarding the downloaded .zip file.  You should always right click on the .zip file and select "unblock" to avoid the annoying security warnings.

[images here]




Added a bug fix and a couple of enhancements.

1.  In EffectHelper class, put ListErrorField method back in; it had been accidentally omitted during the Helper upgrade.
2.  In CombatSystem, added new option to display offender's weapon during attack.  Controlled by the WeaponRevealType enum.
	a.  Never:  weapon never displayed (the current behavior and the default)
	b.  OnlyIfSeen:  weapon displayed if the Seen flag is true
	c.  Always:  weapon always displayed
3.  In CombatSystem, if the offender can attack multiple times [ABS(AttackCount) > 1], and the Monster.CanAttackWithMultipleWeapons method returns true (must be overridden in game; by default it returns false) then offender will cycle round-robin through all carried weapons, attacking once with each.  If offender has more attacks than weapons, it will cycle through those weapons repeatedly.



Baron Jemmas swings at the horl choo.
 ... A fumble!
  Sparks fly from an energy mace!


Baron Jemmas swings at the horl choo with an energy mace.
 ... A fumble!
  Sparks fly from it!

Baron Jemmas swings at the horl choo with an energy mace.		// Use this one!
 ... A fumble!
  Sparks fly from the energy mace!

Helfrick stabs at a kobold with a green glass broadsword.		// Use this one!
 ... A fumble!
  Helfrick drops the green glass broadsword!


Helfrick tends to a garden with a garden hose.




Now that work on the Eamon CS game engine has been completed, its time to turn to the documentation set once again.  This document is called WorkingDraft, but in fact it will be a giant brain-dump of information – everything I can think of will go in here, complete with screen shots, diagrams, antecdotes, etc.  Please be aware that it will be stream-of-consciousness with little or no attention payed to grammatical correctness, paragraph/sentence structure, or clever segues between topics.  It will also be lacking a formality found in most polished documentation sets.  You may find that topical material has been duplicated or sprawled across different sections.  The hope is that you will get the information conveyed and the fit and finish can be left for later when all the factual bits are written down.  To allow you to keep up with the progress of this document, which may grow quite large, I will avoid making changes within it to already-written text and instead append all new changes to the end with appropriate datestamp.

I'll start off by adding the text of the README.htm document which is now superceded:


Overhauled Helper class hierarchy to eliminate Field/Args classes and associated interfaces.  This is a continuation
of the transformation of the data input/editing/validation logic started earlier; finally jettisoned atrociously bad
and convoluted Field class implementation (which I've hated from the moment it was created 3+ years ago) for cleaner,
more elegant architecture based on reflective lookups of method names and properties.



programmatically manipulating a .sln file:  https://stackoverflow.com/questions/8064675/serialize-and-deserialize-visual-studio-solution-files-or-programmatically-edi
programmatically building a C# .csproj file:  https://stackoverflow.com/questions/9942499/building-programmatically-a-project

THIS CODE MIGHT BE USEFUL IN A POSSIBLE FUTURE "Eamon CS Custom Adventure Bootstrapper" PROGRAM.  THIS SECTION
OF TEXT WOULD BE PRESENTED JUST BEFORE THE USER IS QUERIES AS TO WHICH GAME BASE CLASSES THEY NEED TO INCLUDE
IN THEIR GAME DLL FOR OVERRIDE (Eg, Room, Monster, Etc):

	If you know definitively which base classes you need to override you can select them here.  If you are
	not sure, you can always just select the default; the system will work fine if you create empty "stub"
	subclasses and don't put any code in them.  Plus you can build your game and then delete the classes
	you don't need during cleanup (be sure to do a find-and-replace in the relevant .XML files, changing
	your deleted classes back to the base classes).


Would you like to subclass Artifact (Y/N) [Y]: 

Would you like to subclass Monster (Y/N) [Y]: 

Would you like to subclass Room (Y/N) [Y]: 

ETC...





		public virtual void ListField(string fieldName)
		{
			Debug.Assert(!string.IsNullOrWhiteSpace(fieldName));

			var methodName = string.Format("List{0}", fieldName);

			var methodInfo = GetType().GetMethod(methodName, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);

			if (methodInfo != null)
			{
				var origListNum = ListNum;

				methodInfo.Invoke(this, null);

				if (origListNum + 1 == ListNum)
				{
					ListedNames.Add(GetName(fieldName));
				}
			}
		}



using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp3
{
	class Program
	{
		static string Name = "Categories[2].Field2";

		static long Index = -1;

		static string ConvertNameToFieldName(string name)
		{
			Debug.Assert(!string.IsNullOrWhiteSpace(name));

			var delims = new char[] { '[', ']', '.' };

			var tokens = name.Split(delims);

			if (tokens.Length > 1)
			{
				Index = long.Parse(tokens[1]);

				return tokens[0] + tokens[3];
			} 
			else
			{
				return /* base.ConvertNameToFieldName(name); */ tokens[0];
			}
		}

		static void Main(string[] args)
		{
			var fieldName = ConvertNameToFieldName(Name);
		}
	}
}





using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp1
{
	public class Foo
	{
		public void Bar()
		{
			Baz();
		}

		public void Baz()
		{
			Program.PrintCallStack();
		}
	}

	class Program
	{
		static public void PrintCallStack()
		{
			System.Diagnostics.StackTrace t = new System.Diagnostics.StackTrace();

			var frames = t.GetFrames();

			foreach (var f in frames)
			{
				Console.WriteLine(f.GetMethod());
			}
		}

		static void Main(string[] args)
		{
			var f = new Foo();

			f.Bar();
		}
	}
}




Note: relying on this method is a bit dangerous, as refactoring of code can cause method names to change.  You should
ALWAYS put a note in the code where you are making assumptions that a method name won't change because the standard
name refactor logic won't find these kinds of hidden assumptions.







	Initially this was implemented to support disablement of spell commands in Walled City Of Darkness, but it 
	became quickly apparent this command has profound implications.  You could build a very sophisticated
	custom game by just overriding CheckPlayerCommand and leaving all the other States and Commands alone!



	<summary>
	Takes a string (typically a Desc property), does full macro replacement, and prints it.  If the string
	contains "page break" macros (@@PB) the method will split the string into pages, displaying each.
	</summary>


in Command:

protected virtual void PlayerProcessEvents(long eventType)
{

}


in LightCommand:

protected const long BeforeLightOut = 1;
protected const long BeforeLightActivated = 2;


protected override void PlayerExecute()
{
	...

	PlayerProcessEvents(BeforeLightOut);

	...

	PlayerProcessEvents(BeforeLightActivated);

	...
}

in game-specific LightCommand:

protected override void PlayerProcessEvents(long eventType)
{
	if (eventType == BeforeLightOut)
	{

	}
	else if (eventType == BeforeLightActivated)
	{
	
	}
}





Major simplification to the implementation of game-related classes.  Up till now there has been a rigorous parallel
between interfaces in Framework and corresponding concretes in Game.  This has produced numerous empty interfaces 
that in retrospect are just cluttering up the code base.  Now it may be useful to keep this parallel at the game
level when game-specific interfaces introduce new properties or methods, but by cutting them out it greatly reduces
the clutter and actually simplifies the ClassMapping adornment as well.



// AttackCommand.cs

// Copyright (c) 2014+ by Michael R. Penner.  All rights reserved

using System;
using System.Diagnostics;
using Eamon.Game.Attributes;
using Eamon.Game.Extensions;
using TheTempleOfNgurct.Framework;
using TheTempleOfNgurct.Framework.Commands;
using static TheTempleOfNgurct.Game.Plugin.PluginContext;

namespace TheTempleOfNgurct.Game.Commands
{
	[ClassMappings(typeof(EamonRT.Framework.Commands.IAttackCommand))]
	public class AttackCommand : EamonRT.Game.Commands.AttackCommand, IAttackCommand
	{
		protected override void PlayerExecute()
		{
			Debug.Assert(DobjArtifact != null || DobjMonster != null);

			var gameState = Globals.GameState as IGameState;

			Debug.Assert(gameState != null);

			if (BlastSpell || ActorMonster.Weapon > 0)
			{
				// ATTACK/BLAST statue

				if (DobjArtifact != null && DobjArtifact.Uid == 50)
				{
					Globals.Engine.PrintMonsterAlive(DobjArtifact);

					DobjArtifact.SetInLimbo();

					var ngurctMonster = Globals.MDB[53];

					Debug.Assert(ngurctMonster != null);

					ngurctMonster.SetInRoom(ActorRoom);

					Globals.Engine.CheckEnemies();

					var command = Globals.CreateInstance<EamonRT.Framework.Commands.IAttackCommand>(x =>
					{
						x.BlastSpell = BlastSpell;

						x.CheckAttack = CheckAttack;
					});

					CopyCommandData(command);

					command.Dobj = ngurctMonster;

					NextState = command;
				}

				// Fireball wand

				else if (DobjMonster != null && ActorMonster.Weapon == 63)
				{
					Globals.Out.Write("{0}What is the trigger word? ", Environment.NewLine);

					Globals.Buf.SetFormat("{0}", Globals.In.ReadLine());

					if (!string.Equals(Globals.Buf.ToString(), "fire", StringComparison.OrdinalIgnoreCase))
					{
						Globals.Out.Print("Wrong!  Nothing happens!");

						NextState = Globals.CreateInstance<EamonRT.Framework.States.IMonsterStartState>();

						goto Cleanup;
					}

					if (gameState.WandCharges <= 0)
					{
						Globals.Out.Print("The fireball wand is exhausted!");

						NextState = Globals.CreateInstance<EamonRT.Framework.States.IMonsterStartState>();

						goto Cleanup;
					}

					gameState.WandCharges--;

					Globals.Out.Print("The {0} is filled with an incandescent fireball!", ActorRoom.EvalRoomType("room", "area"));

					var slaveGirlFireballCheck = false;

					var slaveGirlArtifact = Globals.ADB[...];

					Debug.Assert(slaveGirlArtifact != null);

					var slaveGirlMonster = Globals.MDB[...];

					Debug.Assert(slaveGirlMonster != null);

					if (slaveGirlArtifact.IsInRoom(ActorRoom))
					{
						slaveGirlMonster.SetInRoom(ActorRoom);

						slaveGirlMonster.Seen = true;

						slaveGirlFireballCheck = true;
					}

					var monsters = Globals.Engine.GetRandomMonsterList(9, m => !m.IsCharacterMonster() && m.Uid != DobjMonster.Uid && m.Seen && m.IsInRoom(ActorRoom));

					Debug.Assert(monsters != null);

					if (monsters.Count > 0)
					{
						monsters.Insert(0, DobjMonster);
					}
					else
					{
						monsters.Add(DobjMonster);
					}

					Globals.FireDamage = true;

					foreach (var m in monsters)
					{
						var rl = Globals.Engine.RollDice01(1, 100, 0);

						var savedVsFire = (m.Hardiness / 4) > 4 && rl < 51;

						Globals.Engine.MonsterGetsAggravated(m);

						var combatSystem = Globals.CreateInstance<EamonRT.Framework.Combat.ICombatSystem>(x =>
						{
							x.SetNextStateFunc = s => NextState = s;

							x.DfMonster = m;

							x.OmitArmor = true;
						});

						combatSystem.ExecuteCalculateDamage(savedVsFire ? 3 : 6, 6);
					}

					Globals.FireDamage = false;

					if (slaveGirlFireballCheck)
					{
						slaveGirlMonster.Seen = false;

						if (slaveGirlMonster.IsInLimbo())
						{
							slaveGirlArtifact.SetInLimbo();
						}
						else
						{
							slaveGirlMonster.SetInLimbo();
						}
					}

					NextState = Globals.CreateInstance<EamonRT.Framework.States.IMonsterStartState>();

					goto Cleanup;
				}
				else
				{
					base.PlayerExecute();
				}
			}
			else
			{
				base.PlayerExecute();
			}

		Cleanup:

			;
		}
	}
}




[Note: verify this!]

The disambiguation rules followed by the parser are:  when your input matches multiple objects that
all have identical names, the first object in the list will be chosen.  If the objects have different
names, then you will receive the "which one?" response.


			command.Dobj = monster.AttackCount > 1 && Globals.LastDfMonster != null && monsterList.Contains(Globals.LastDfMonster) ? Globals.LastDfMonster : monsterList[(int)rl - 1];

			Globals.LastDfMonster = command.Dobj as IMonster;





Initial checkin of Eamon CS 1.4.0; this is a breaking upgrade, but only for any outstanding save games you have.  You can either discard them or upgrade them by doing Find/Replace In Files on ARTIFACTS_XXX.XML, replacing ArtifactClass with ArtifactCategory and 1.3.0.0 with 1.4.0.0.  Your CHARACTERS.XML file is fully compatible and can be brought over as is.


Added the ability to "caesar" and "uncaesar" text files using the Utilities menu in EamonDD.  This is 
another name for obfustication using a 16-bit integer key.  This menu option will only show up when
an adventure is not being edited.


Added an option to EamonDD Utilities menu to support using a caesar cipher on text files.  This option is
only available when not editing an adventure.  The idea here is to use this in conjunction with the 
LoadTextFile method, allowing a game designer to load and print obfusticated text files during gameplay.


https://stackoverflow.com/questions/13025949/simple-obfuscation-of-string-in-net

public static string Caesar(this string source, Int16 shift)
{
    var maxChar = Convert.ToInt32(char.MaxValue);
    var minChar = Convert.ToInt32(char.MinValue);

    var buffer = source.ToCharArray();

    for (var i = 0; i < buffer.Length; i++)
    {
        var shifted = Convert.ToInt32(buffer[i]) + shift;

        if (shifted > maxChar)
        {
            shifted -= maxChar;
        }
        else if (shifted < minChar)
        {
            shifted += maxChar;
        }

        buffer[i] = Convert.ToChar(shifted);
    }

    return new string(buffer);
}


var plain = "Wibble";
var caesered = plain.Caesar(42);
var newPlain = caesered.Caesar(-42);





	EamonDD -icf input.txt -ocf output.txt -ck 37


	-icf
	-inputCaesarFile

	-ocf
	-outputCaesarFile

	-ck
	-caesarKey



... or maybe make this an EamonDD Utilities menu option ???


	3. Caesar/Uncaesar text file

[X]: 3

Enter input file name: desertmap.txt
Enter output file name: desertmap_caesared.txt
Enter caesar key: 42

Done.

...
